# 序列化与反序列化
##什么是序列化？
* 使用Java的序列化和反序列化可以实现信息的持久存储、或者也可以实现Java对象的深克隆

* 为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来

##什么情况下可以序列化？
* 想把的内存中的对象状态保存到一个文件中或者数据库中时候

* 想用套接字在网络上传送对象的时候

##对象序列化的含义
- Java 序列化技术可以使你将一个对象的状态写入一个Byte 流里，并且可以从其它地方把该Byte 流里的数据读出来，重新构造一个相同的对象。

- 这种机制允许你将对象通过网络进行传播，并可以随时把对象持久化到数据库、文件等系统里

##什么是反序列化？

* 反序列化的时候，并没有调用类的构造方法。而是直接根据他们的序列化数据在内存中创建新的对像

##其他
* 序列化时，只对对象的**状态**进行保存，而不管对象的方法

* Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常 
    * 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 `private static final long serialVersionUID = 1L`，虽然两个类的功能代码完全一致，但是序列化 ID 不同，他们无法相互序列化和反序列化

* 加入**transient**关键字的field不会被序列化

* 当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口

* 当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化

* 并非所有的对象都可以序列化
    * 安全原因：如果一个private实例被序列化后，在传输过程中不再受到保护


