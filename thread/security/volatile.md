# volatile关键字
##性质
###线程的可见性
用volatiole修饰的成员变量都强迫从主内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到主内存。
- 这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 
- 使用volatile修饰的修饰的变量会对多个线程可见，也就是说任何线程都可以看到被volatile修饰的变量的最终值。

###禁止重排序
1. 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行
2. 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行

###对于64位数据
**不允许**读写操作分为两次32位数据进行
##指令重排序
一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
###一个不会影响结果的重排序例子—单线程
```java
int a = 10;    //语句1
int r = 2;    //语句2
a = a + 3;    //语句3
r = a*a;     //语句4
```
语句**不可能**的执行顺序：语句2==>语句1==>语句4==>语句3
- 处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行

###影响结果的重排序例子—多线程
```java
//线程1
contex = loadContext(); //语句1
inited = true; //语句2

//线程2
while(!inited){
	sleep(1);
}
doSomethingWithConfig(contex); //语句3
```
因为语句1与语句2**没有**数据依赖性，所以可能被重排序。
- 如果线程1中语句2先发送，然后线程2会立即执行语句3，此时context没有被初始化，可能发生错误

##volatile不保证线程安全性
由于volatile只提供了可见性，并没有提供互斥性，volatile不能替代synchronized
- 在多线程并发修改某个变量值时，依然会出现并发问题。

###volatile适用场景
一个线程修改被volatile修饰的变量，其他多个线程获取这个变量的值；当多个线程并发修改某个变量值时，必须使用synchronized来进行互斥同步。

##volatile变量与atomic变量有什么不同？
1. volatile变量可以确保**先行关系**，但是它不保证原子性
	- 例如：用volatile修饰count变量，那么count++操作不是原子性的
	
2. AtomicInteger类提供的atomic方法可以让这种操作具有原子性，例如：getAndIncrement()方法会原子性的进行增量操作，并把当前值加1